{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Pipe, NgModule, InjectionToken, Injectable, Inject } from '@angular/core';\nimport { decode } from 'blurhash';\nimport { Observable, of } from 'rxjs';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { mergeMap } from 'rxjs/operators';\nclass BlurHashPipe {\n  /**\n   * [BlurHash placeholder](https://unsplash.com/documentation#blurhash-placeholders).\n   *\n   * Returns a URL of the BlurHash preview and then the URL of photo once the\n   * photo been downloaded by the browser.\n   *\n   * @param photo to download\n   * @param size to be returned, the default is thumb\n   * @returns Observable of URL\n   */\n  transform(photo, size = 'thumb') {\n    return new Observable(observer => {\n      // Send URL of blur hash image\n      observer.next(this.getImageFromBlurHash(photo).toDataURL());\n      const img = new Image();\n      img.src = photo.urls[size];\n      img.onload = () => {\n        // Send URL of loaded image\n        observer.next(img.src);\n        observer.complete();\n      };\n      img.onerror = err => observer.error(err);\n    });\n  }\n  getImageFromBlurHash(photo) {\n    const canvas = document.createElement('canvas');\n    let width = photo.width || 240;\n    let r = width / 240;\n    canvas.width = width / r;\n    canvas.height = (photo.height || 180) / r;\n    try {\n      if (photo.blur_hash) {\n        const pixels = decode(photo.blur_hash, canvas.width, canvas.height);\n        const ctx = canvas.getContext('2d');\n        const imageData = ctx.createImageData(canvas.width, canvas.height);\n        imageData.data.set(pixels);\n        ctx.putImageData(imageData, 0, 0);\n      }\n    } catch {}\n    return canvas;\n  }\n}\nBlurHashPipe.ɵfac = function BlurHashPipe_Factory(t) {\n  return new (t || BlurHashPipe)();\n};\nBlurHashPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"blurhash\",\n  type: BlurHashPipe,\n  pure: true\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BlurHashPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'blurhash'\n    }]\n  }], null, null);\n})();\nclass NgxUnsplashModule {}\nNgxUnsplashModule.ɵfac = function NgxUnsplashModule_Factory(t) {\n  return new (t || NgxUnsplashModule)();\n};\nNgxUnsplashModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxUnsplashModule\n});\nNgxUnsplashModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxUnsplashModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [BlurHashPipe],\n      imports: [],\n      exports: [BlurHashPipe]\n    }]\n  }], null, null);\n})();\nconst UNSPLASH_CONFIG = new InjectionToken('unsplash.config');\nclass UnsplashService {\n  constructor(http, config) {\n    this.http = http;\n    this.searchUrl = 'search/photos';\n    this.photosUrl = 'photos';\n    this.randomUrl = 'photos/random';\n    if (config instanceof Observable) {\n      this.config$ = config;\n    } else {\n      this.config$ = of(config);\n    }\n  }\n  /**\n   * [List photos](https://unsplash.com/documentation#list-photos).\n   *\n   * Get a single page from the list of all photos.\n   *\n   * @param options to be used when getting list of photos\n   * @returns Observable containing a {@link Photo} array\n   */\n  list(options) {\n    return this.config$.pipe(mergeMap(config => {\n      if (!config) {\n        throw new Error('Unsplash configuration undefined');\n      }\n      let headers = new HttpHeaders().set('authorization', config.authorization);\n      let params = new HttpParams();\n      if (options.page) {\n        params = params.set('page', options.page);\n      }\n      if (options.perPage) {\n        params = params.set('per_page', options.perPage);\n      }\n      if (options.orderBy) {\n        params = params.set('order_by', options.orderBy);\n      }\n      const url = new URL(this.photosUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n      return this.http.get(url, {\n        params,\n        headers\n      });\n    }));\n  }\n  /**\n   * [Get a photo](https://unsplash.com/documentation#get-a-photo).\n   *\n   * Retrieve a single photo.\n   *\n   * @param id of the photo\n   * @returns  Observable containing the {@link Photo}\n   */\n  get(id) {\n    return this.config$.pipe(mergeMap(config => {\n      if (!config) {\n        throw new Error('Unsplash configuration undefined');\n      }\n      const url = new URL(this.photosUrl + '/' + id, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n      let headers = new HttpHeaders().set('authorization', config.authorization);\n      return this.http.get(url, {\n        headers\n      });\n    }));\n  }\n  /**\n   * [Get random photos](https://unsplash.com/documentation#get-a-random-photo).\n   *\n   * Retrieve random photos.\n   *\n   * @param options to be used when getting random photos\n   * @returns Observable containing a {@link Photo} array\n   */\n  random(options) {\n    return this.config$.pipe(mergeMap(config => {\n      if (!config) {\n        throw new Error('Unsplash configuration undefined');\n      }\n      let params = new HttpParams();\n      if (options?.collections) {\n        params = params.set('collections', options?.collections);\n      }\n      if (options?.topics) {\n        params = params.set('topics', options?.topics);\n      }\n      if (options?.username) {\n        params = params.set('username', options?.username);\n      }\n      if (options?.query) {\n        params = params.set('query', options?.query);\n      }\n      if (options?.orientation) {\n        params = params.set('orientation', options?.orientation);\n      }\n      if (options?.contentFilter) {\n        params = params.set('content_filter', options?.contentFilter);\n      }\n      if (options?.count) {\n        params = params.set('count', options?.count);\n      }\n      let headers = new HttpHeaders().set('authorization', config.authorization);\n      const url = new URL(this.randomUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n      return this.http.get(url, {\n        headers,\n        params\n      });\n    }));\n  }\n  /**\n   * [Search photos](https://unsplash.com/documentation#search-photos).\n   *\n   * Get a single page of photo results for a query.\n   *\n   * @param query to search for\n   * @param options to be used when searching photos\n   * @returns Observable containing a {@link SearchResult}\n   */\n  search(query, options) {\n    return this.config$.pipe(mergeMap(config => {\n      if (!config) {\n        throw new Error('Unsplash configuration undefined');\n      }\n      let params = new HttpParams().set('query', query);\n      if (options?.page) {\n        params = params.set('page', options?.page);\n      }\n      if (options?.perPage) {\n        params = params.set('per_page', options?.perPage);\n      }\n      if (options?.orderBy) {\n        params = params.set('order_by', options?.orderBy);\n      }\n      if (options?.collections) {\n        params = params.set('collections', options?.collections);\n      }\n      if (options?.contentFilter) {\n        params = params.set('content_filter', options?.contentFilter);\n      }\n      if (options?.color) {\n        params = params.set('color', options?.color);\n      }\n      if (options?.orientation) {\n        params = params.set('orientation', options?.orientation);\n      }\n      let headers = new HttpHeaders().set('authorization', config.authorization);\n      const url = new URL(this.searchUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n      return this.http.get(url, {\n        headers,\n        params\n      });\n    }));\n  }\n  /**\n   * [Trigger a download](https://help.unsplash.com/en/articles/2511258-guideline-triggering-a-download)\n   * of a photo.\n   *\n   * @param photo to download\n   * @returns Observable containing the {@link Download}\n   */\n  download(photo) {\n    return this.config$.pipe(mergeMap(config => {\n      if (!config) {\n        throw new Error('Unsplash configuration undefined');\n      }\n      let headers = new HttpHeaders().set('authorization', config.authorization);\n      const photoUrl = new URL(photo.links.download_location);\n      const url = new URL(photoUrl.pathname.substr(1) + photoUrl.search, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n      return this.http.get(url, {\n        headers\n      });\n    }));\n  }\n}\nUnsplashService.ɵfac = function UnsplashService_Factory(t) {\n  return new (t || UnsplashService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(UNSPLASH_CONFIG));\n};\nUnsplashService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UnsplashService,\n  factory: UnsplashService.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UnsplashService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [UNSPLASH_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\n/*\n * Public API Surface of ngx-unsplash\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlurHashPipe, NgxUnsplashModule, UNSPLASH_CONFIG, UnsplashService };","map":{"version":3,"names":["i0","Pipe","NgModule","InjectionToken","Injectable","Inject","decode","Observable","of","i1","HttpHeaders","HttpParams","mergeMap","BlurHashPipe","transform","photo","size","observer","next","getImageFromBlurHash","toDataURL","img","Image","src","urls","onload","complete","onerror","err","error","canvas","document","createElement","width","r","height","blur_hash","pixels","ctx","getContext","imageData","createImageData","data","set","putImageData","ɵfac","ɵpipe","type","args","name","NgxUnsplashModule","ɵmod","ɵinj","declarations","imports","exports","UNSPLASH_CONFIG","UnsplashService","constructor","http","config","searchUrl","photosUrl","randomUrl","config$","list","options","pipe","Error","headers","authorization","params","page","perPage","orderBy","url","URL","endsWith","toString","get","id","random","collections","topics","username","query","orientation","contentFilter","count","search","color","download","photoUrl","links","download_location","pathname","substr","HttpClient","ɵprov","providedIn","undefined","decorators"],"sources":["C:/Users/Oriol/Desktop/hackaton vueling/unsplashAPI/unsplash-viewer/node_modules/@berry-cloud/ngx-unsplash/fesm2020/berry-cloud-ngx-unsplash.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Pipe, NgModule, InjectionToken, Injectable, Inject } from '@angular/core';\nimport { decode } from 'blurhash';\nimport { Observable, of } from 'rxjs';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams } from '@angular/common/http';\nimport { mergeMap } from 'rxjs/operators';\n\nclass BlurHashPipe {\n    /**\n     * [BlurHash placeholder](https://unsplash.com/documentation#blurhash-placeholders).\n     *\n     * Returns a URL of the BlurHash preview and then the URL of photo once the\n     * photo been downloaded by the browser.\n     *\n     * @param photo to download\n     * @param size to be returned, the default is thumb\n     * @returns Observable of URL\n     */\n    transform(photo, size = 'thumb') {\n        return new Observable((observer) => {\n            // Send URL of blur hash image\n            observer.next(this.getImageFromBlurHash(photo).toDataURL());\n            const img = new Image();\n            img.src = photo.urls[size];\n            img.onload = () => {\n                // Send URL of loaded image\n                observer.next(img.src);\n                observer.complete();\n            };\n            img.onerror = (err) => observer.error(err);\n        });\n    }\n    getImageFromBlurHash(photo) {\n        const canvas = document.createElement('canvas');\n        let width = photo.width || 240;\n        let r = width / 240;\n        canvas.width = width / r;\n        canvas.height = (photo.height || 180) / r;\n        try {\n            if (photo.blur_hash) {\n                const pixels = decode(photo.blur_hash, canvas.width, canvas.height);\n                const ctx = canvas.getContext('2d');\n                const imageData = ctx.createImageData(canvas.width, canvas.height);\n                imageData.data.set(pixels);\n                ctx.putImageData(imageData, 0, 0);\n            }\n        }\n        catch { }\n        return canvas;\n    }\n}\nBlurHashPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: BlurHashPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });\nBlurHashPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"14.0.0\", version: \"14.2.9\", ngImport: i0, type: BlurHashPipe, name: \"blurhash\" });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: BlurHashPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'blurhash',\n                }]\n        }] });\n\nclass NgxUnsplashModule {\n}\nNgxUnsplashModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: NgxUnsplashModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxUnsplashModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.9\", ngImport: i0, type: NgxUnsplashModule, declarations: [BlurHashPipe], exports: [BlurHashPipe] });\nNgxUnsplashModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: NgxUnsplashModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: NgxUnsplashModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [BlurHashPipe],\n                    imports: [],\n                    exports: [BlurHashPipe],\n                }]\n        }] });\n\nconst UNSPLASH_CONFIG = new InjectionToken('unsplash.config');\nclass UnsplashService {\n    constructor(http, config) {\n        this.http = http;\n        this.searchUrl = 'search/photos';\n        this.photosUrl = 'photos';\n        this.randomUrl = 'photos/random';\n        if (config instanceof Observable) {\n            this.config$ = config;\n        }\n        else {\n            this.config$ = of(config);\n        }\n    }\n    /**\n     * [List photos](https://unsplash.com/documentation#list-photos).\n     *\n     * Get a single page from the list of all photos.\n     *\n     * @param options to be used when getting list of photos\n     * @returns Observable containing a {@link Photo} array\n     */\n    list(options) {\n        return this.config$.pipe(mergeMap(config => {\n            if (!config) {\n                throw new Error('Unsplash configuration undefined');\n            }\n            let headers = new HttpHeaders().set('authorization', config.authorization);\n            let params = new HttpParams();\n            if (options.page) {\n                params = params.set('page', options.page);\n            }\n            if (options.perPage) {\n                params = params.set('per_page', options.perPage);\n            }\n            if (options.orderBy) {\n                params = params.set('order_by', options.orderBy);\n            }\n            const url = new URL(this.photosUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n            return this.http.get(url, { params, headers });\n        }));\n    }\n    /**\n     * [Get a photo](https://unsplash.com/documentation#get-a-photo).\n     *\n     * Retrieve a single photo.\n     *\n     * @param id of the photo\n     * @returns  Observable containing the {@link Photo}\n     */\n    get(id) {\n        return this.config$.pipe(mergeMap(config => {\n            if (!config) {\n                throw new Error('Unsplash configuration undefined');\n            }\n            const url = new URL(this.photosUrl + '/' + id, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n            let headers = new HttpHeaders().set('authorization', config.authorization);\n            return this.http.get(url, { headers });\n        }));\n    }\n    /**\n     * [Get random photos](https://unsplash.com/documentation#get-a-random-photo).\n     *\n     * Retrieve random photos.\n     *\n     * @param options to be used when getting random photos\n     * @returns Observable containing a {@link Photo} array\n     */\n    random(options) {\n        return this.config$.pipe(mergeMap(config => {\n            if (!config) {\n                throw new Error('Unsplash configuration undefined');\n            }\n            let params = new HttpParams();\n            if (options?.collections) {\n                params = params.set('collections', options?.collections);\n            }\n            if (options?.topics) {\n                params = params.set('topics', options?.topics);\n            }\n            if (options?.username) {\n                params = params.set('username', options?.username);\n            }\n            if (options?.query) {\n                params = params.set('query', options?.query);\n            }\n            if (options?.orientation) {\n                params = params.set('orientation', options?.orientation);\n            }\n            if (options?.contentFilter) {\n                params = params.set('content_filter', options?.contentFilter);\n            }\n            if (options?.count) {\n                params = params.set('count', options?.count);\n            }\n            let headers = new HttpHeaders().set('authorization', config.authorization);\n            const url = new URL(this.randomUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n            return this.http.get(url, { headers, params });\n        }));\n    }\n    /**\n     * [Search photos](https://unsplash.com/documentation#search-photos).\n     *\n     * Get a single page of photo results for a query.\n     *\n     * @param query to search for\n     * @param options to be used when searching photos\n     * @returns Observable containing a {@link SearchResult}\n     */\n    search(query, options) {\n        return this.config$.pipe(mergeMap(config => {\n            if (!config) {\n                throw new Error('Unsplash configuration undefined');\n            }\n            let params = new HttpParams().set('query', query);\n            if (options?.page) {\n                params = params.set('page', options?.page);\n            }\n            if (options?.perPage) {\n                params = params.set('per_page', options?.perPage);\n            }\n            if (options?.orderBy) {\n                params = params.set('order_by', options?.orderBy);\n            }\n            if (options?.collections) {\n                params = params.set('collections', options?.collections);\n            }\n            if (options?.contentFilter) {\n                params = params.set('content_filter', options?.contentFilter);\n            }\n            if (options?.color) {\n                params = params.set('color', options?.color);\n            }\n            if (options?.orientation) {\n                params = params.set('orientation', options?.orientation);\n            }\n            let headers = new HttpHeaders().set('authorization', config.authorization);\n            const url = new URL(this.searchUrl, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n            return this.http.get(url, { headers, params });\n        }));\n    }\n    /**\n     * [Trigger a download](https://help.unsplash.com/en/articles/2511258-guideline-triggering-a-download)\n     * of a photo.\n     *\n     * @param photo to download\n     * @returns Observable containing the {@link Download}\n     */\n    download(photo) {\n        return this.config$.pipe(mergeMap(config => {\n            if (!config) {\n                throw new Error('Unsplash configuration undefined');\n            }\n            let headers = new HttpHeaders().set('authorization', config.authorization);\n            const photoUrl = new URL(photo.links.download_location);\n            const url = new URL(photoUrl.pathname.substr(1) + photoUrl.search, config.url.endsWith('/') ? config.url : config.url + '/').toString();\n            return this.http.get(url, { headers });\n        }));\n    }\n}\nUnsplashService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: UnsplashService, deps: [{ token: i1.HttpClient }, { token: UNSPLASH_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\nUnsplashService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: UnsplashService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.9\", ngImport: i0, type: UnsplashService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [UNSPLASH_CONFIG]\n                }] }]; } });\n\n/*\n * Public API Surface of ngx-unsplash\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlurHashPipe, NgxUnsplashModule, UNSPLASH_CONFIG, UnsplashService };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}